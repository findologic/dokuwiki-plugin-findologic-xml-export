====== Nützliche Code Fragmente für Direkte Integration ======

Auf dieser Seite findet sich eine Sammlung von Funktionalitäten als Code Stückchen die nützlich sein könnten:

===== Mehrere div's aus einem Template in einer Seite (an unterschiedlichen Stellen) einbinden =====

2 divs aus dem Template nehmen und im **Success-Callback** an die richtige Stelle schieben. Danach umbenennen, damit die CSS Zuweisungen funktionieren.

<code>
jQuery("#breadcrumb-wrapper").remove();
jQuery(response.find("#fl-breadcrumb-wrapper").insertBefore("#content-wrapper"));
jQuery("#fl-breadcrumb-wrapper").attr("id","breadcrumb-wrapper");
jQuery(response.find("#fl-content-wrapper")).insertAfter("#breadcrumb-wrapper");
jQuery("#content-wrapper").remove();
jQuery("#fl-content-wrapper").attr("id","content-wrapper");
</code>

===== Vor & Rückansichten von Produktbildern toggeln =====

  * Beide Produktbilder im Template ausgeben.

<code>
                  	{* Default image link front *}
                    <div class="fl-image-front" id="{$product.ID}">
                    	<img src="{$IMAGEURL}{$product.IMAGE}" alt="Vorschaubild" itemprop="image" class="productImage height229" id="primaryImage">
                    </div>
                        {* Default image link back *}
                    <div class="fl-image-back" id="back_{$product.ID}">
                     	<img src="{$IMAGEURL}{$color.image_back}" alt="Vorschaubild" itemprop="image" class="productImage height229" id="primaryImage">
                    </div>
</code>

  * Per CSS die Rückansicht ausblenden

<code>
.fl-image-back {
	display: none;
}
</code>

  * Im Success Callback den toggle per klick auf ein Item aktivieren:


<code>
jQuery("#product-list-rotate-wrapper").click(function(){
jQuery(".fl-image-front,.fl-image-back").toggle();
});
</code>

===== Weitere Filterwerte nach X Werten erst per klick anzeigen =====

  * Filter ausklappbar (nach 5 Elementen erst per klick einblenden)

Global:


<code>
{assign var="FILTERVALUES" value="5"} {* Assign number of Filter Values displayed *}
</code>

Jeder Filter:

<code>
    	{assign var="filter" value="##MYFILTERNAME##"}
		<div class="facet-values">
			<div class="topFacetValues" style="display: block;">
				<ul class="indent">
		                            {foreach from=$FILTERS.$filter.filters key=i item=filteritem name=currentfilter}
		                            	{if $smarty.foreach.currentfilter.iteration <= $FILTERVALUES}
										<li class="facet-list-item flChosenFilter">
										<a class="facet-value-selector" href="?{$filteritem.link}">{$filteritem.name}</a>
										({$filteritem.frequency})
										</li>
										{/if}
		                            {/foreach}
				</ul>
				{if $smarty.foreach.currentfilter.iteration > $FILTERVALUES}
				<a class="facet-show-more clear" onclick="$(this).closest('div.topFacetValues').hide().siblings('div.allFacetValues').show();return false;" href="#">mehr ...</a>
				{/if}
			</div>
			<div class="allFacetValues" style="display: none;">
				<ul class="indent">
		                            {foreach from=$FILTERS.$filter.filters key=i item=filteritem name=currentfilter}
										<li class="facet-list-item flChosenFilter">
										<a class="facet-value-selector" href="?{$filteritem.link}">{$filteritem.name}</a>
										({$filteritem.frequency})
										</li>
		                            {/foreach}
				</ul>
			<a class="facet-show-more clear" onclick="$(this).closest('div.allFacetValues').hide().siblings('div.topFacetValues').show();return false;" href="#">weniger ...</a>
			</div>

		</div>
</code>


===== Farbfilter in Kacheln =====

  * Beim Farbfilter in der Filterkonfiguration Mehrfachauswahl aktiveren
  * HTML:

<code>
            {assign var="filter" value="Farbe"}
		            <div id="fl-ColorFilter">
                            {filter name="Farbe" type="color-picker"}
                            </div>

                            {foreach from=$CHOSEN_FILTERS key=i item=cfilter name=cfilters}
                                {foreach from=$cfilter key=i item=sfilter name=foo}
                                    {if $sfilter.name == "Farbe" }
					{* Mark the Filter as selected via JQuery *}
                                        <script type="text/javascript">
                                            jQuery(".colorPicker[title={$sfilter.value}]").parent().parent().css("border","1px solid #E2007A");
                                        </script>
                                    {/if}
                                {/foreach}
                            {/foreach}

</code>

  * CSS:

<code>

.noColorFound {
 float: left;
}

.flFilter.flSelected .colorPickerElementWrapper {
border-color: black;
}

.colorPickerElementWrapper {
 position:relative;
 text-align:center;
 width:25px;
 height:25px;
 padding: 0px;
}

.colorPicker {
 position:absolute;
 border-radius: 2px;
 margin-top: 2px;
 margin-left: 2px;
 width: 21px;
 height: 21px;
}

.noColorFound { padding-top:7px; }

#fl-ColorFilter {
	overflow-y: auto;
}

#fl-ColorFilter li{
	 float: left;
	 margin-right: 5px;
	 margin-bottom: 4px;
     padding: 0px;
}

#fl-ColorFilter a{
    clear: none;
    float: left;
    border: 1px solid #DDD;
    border-radius: 2px;
}

.noColorFound {
    padding-top: 6px !important;
    padding-left: 8px !important;
}

#fl-ColorFilter a:hover {
	border: 1px solid #000;
    display: inline !important;
}


</code>


===== Breadcrumbs der ausgewählten Filter =====

HTML:
<code>

		{foreach from=$CHOSEN_FILTERS key=i item=cfilter name=cfilters}
                        {foreach from=$cfilter key=i item=filter name=foo}
       			<span class="breadcrumb-separator"></span>
                            {if $filter.name == "Kategorie"}

				{assign var="hcat" value="_"|explode:$filter.value}
                                {foreach from=$hcat key=j item=subcat name=subcats}

                                  {if $smarty.foreach.subcats.first}
                                      <a href="?{$filter.link}">{$subcat}</a>
                                  {else}
                                      <span class="breadcrumb-separator"></span>
                                      <a href="?{$filter.link}">{$subcat}</a>
                                  {/if}

                                {/foreach}
                            {else}
                            	<a href="?{$filter.link}">{$filter.value}</a>
                            {/if}
                        {/foreach}
                    {/foreach}
</code>

===== Ergebnisliste in Grid mit 4 Artikeln in Reihe =====

HTML:

<code smarty>
{foreach from=$RESULT key=i item=product name=products}
	{if $i == 0}
		HTML für Header
	{else}
		{if $i%4 == 0}
			HTML nach jeder Reihe
		{else}
			HTML für jedes Item
		{/if}
	{/if}
{/foreach}        
</code>

===== Infinite Scrolling mit Masonry =====

  * Next page link muss im Template in entsprechender Klasse gesetzt werden
  * Next page link zeigt direkt aufs Service
  * jQuery Masonry muss geladen sein (eventuell selbst einbinden
  * jQuery MAsonry muss am angegebenen Container binden.


Success Callback: 

<code javascript>
var msnry = new Masonry( document.querySelector(".masonry"), {
  columnWidth: '.productWaterfall-item',
  itemSelector: '.productWaterfall-item'
});


function isOnScreen(loadingLink){
    if (loadingLink.length < 1) {
      return false;
    }
    var element = loadingLink.get(0);
    var bounds = element.getBoundingClientRect();
    return bounds.top < window.innerHeight && bounds.bottom > 0;
}

directIntegration.loadCount = 0;

function loadMoreItems() {
	var link = jQuery(".masonry-loading-hint>a");
	jQuery.ajax({
		type: "jsonp",
                url: link.attr("href"),
		method: "GET",
		success: function (response){
			var parsedResponse = jQuery("<div>").html(response);
			var newElems = parsedResponse.find(".flMasonryItem");
			$('#productwaterfallcomponent').append( newElems );
                        msnry.appended(newElems);
                        msnry.layout();
          
			var newNextPageLink = parsedResponse.find(".masonry-loading-hint>a");
			if (newNextPageLink.length < 1) {
				link.remove();
                                jQuery(".masonry-loading-hint").remove();
			}
			else {
				link.attr("href", newNextPageLink.attr("href"));
			}
		}
	});
	return false;

}

jQuery(window).on("scroll", function () {
      clearTimeout(jQuery.data(this, 'scrollTimer'));
      jQuery.data(this, 'scrollTimer', setTimeout(function() {
        var loadingLink = jQuery(".masonry-loading-hint>a");
        if (isOnScreen(loadingLink)) {
              //console.log(directIntegration.loadCount);
              directIntegration.loadCount++;
              if (directIntegration.loadCount < 4) {
                  loadMoreItems();
              }
              else {
                  loadingLink.text("Weitere Artikel anzeigen");
                  loadingLink.off("click");
                  loadingLink.click(loadMoreItems);
              }
          }
	}, 50));
});

</code>

===== Suchfeld bei Seitenladen automatisch fokussieren =====

Suchfeld Klasse im Beispiel '.search'. Dies abändern und Code in den Init Callback kopieren.

<code javascript>
jQuery(".search").attr("autofocus", "autofocus");
jQuery(".search").focus();
</code>

===== Promotion Bilder auf ein vernünftiges Maß verkleinern =====

Im Success Callback:

<code javascript>
jQuery(".flPromotion > a > img").css("height", "200px");
jQuery(".flPromotion > a > img").css("margin-bottom", "20px");
</code>

===== Einen Bereich des Shops von Direct Integration Ergebnissen ausschließen =====

Beispiel: alle ShopURL's die unter dem Verzeichnis 'plussize' aufgerufen werden erhalten keine Direct Integration Ergebnisse.

Im Pre-Search Callback:


<code javascript>
if (window.location.toString().indexOf("/plussize")> -1){
	throw "plussize";
  }
</code>

===== Artikelnummernsuche abfangen und ein Präfix anhängen/rausnehmen =====

Beispiel: Suchparameter heißt hier 'text' und wird auf 'query' umgeschrieben. So erwartet es die Direct Integration. Wenn die Suche eine reine Ziffernfolge ist, wird ein Präfix vorangestellt.

Im Pre-Search Callback:

<code javascript>
var query = utils.parseQueryString(queryString);
if ('text' in query) {
    if (jQuery.isNumeric(query['text'])) {
    // we picked up ordernumber search and add prefix: "01"
    var prefix = '1';
    query['text'].toString();
    query['text'] = query['text'].replace(/^\s+|\s+$/g,'')
    query['text'] = prefix.concat(query['text']); 
    }
    query['query'] = query['text'];
}
delete query['text'];
var newQueryString = jQuery.param(query);
return newQueryString;
</code>

Im Success Callback dann noch den querytext umschreiben, sonst merkt mans:
<code javascript>
var queryString = jQuery(".querytext").first().text();
jQuery(".querytext").each(function() {
  if (jQuery.isNumeric(queryString)) { 
    $(this).text(queryString.replace(/^1/, ""));
  }
});
</code>

===== Smart Suggest Responsive light =====

Um mobile die rechte Spalte mit den Produkten auszublenden, fügt man einfach diesen Code im CSS hinzu: 

<code css>
@media screen and (max-width: 550px) {
  #product-list-rotate-wrapper{
    display: none;
  }

  #product-list-rotate-wrapper-down {
    display: none;
  }

  .fl-block-product .fl-item-product {
    display: none !important;
  }

  .fl-item-product, .fl-block-product, .ui-autocomplete-allResults {
      display: none !important;
  }
}
</code>

===== Smart Suggest Identifier löschen =====

Um den identifier - sofern gesetzt - nicht ewig mitzuschicken (als Bug gemeldet!), kann man das hidden-field einfach im ''Search Success Callback'' löschen: 
<code javascript>
jQuery('input[name="identifier"]').remove();
</code>

===== Suche manuell triggern (bei zweitem Suchformular auf Seite) =====

Sollte aus irgendeinem Grund eine Suche manuell getriggert werden müssen (z.b.: zweites Suchformular auf Seite da ein sticky Suchfeld) kann dies wie folgt per JS aufgerufen werden:

<code javascript>
directIntegration.loadContentWhenReady(directIntegration.TYPE_SEARCH, jQuery('selektor des sticky suchformulars').serialize());
</code>

Pre-Search Callback und Search Success Callback werden in Folge wie gewohnt ausgefuehrt. Mit diesem Funktionsaufruf ist alles wie bei normaler Direct Integration Suche.

===== Dynamisches nachladen von Ergebnissen auf Knopfdruck =====

Etwas simplere und einfachere Version für "Infinite Clicking". (Infinite Scrolling folgt)

Einfach in den Search-Success Callback pasten und die directIntegration-Konfigurationsvariablen ersetzen.

<code javascript>
/*** Initialisierung der Konfiguration. ***/
function initValues() {

    /*** Die Anzahl der Items, die auf Knopfdruck nachgeladen werden sollen. ***/
    directIntegration.loadItemStepSize      = 15;

    /*** Die Anzahl der Items, die beim ersten Request geladen werden.
    /*** Wird während der Laufzeit erhöht und gibt den parameter ?count= des Requests an. ***/
    directIntegration.wantedItems           = 30;

    /*** Die Service URL des Shops, Output-Adapter sollte nach Bedarf angepasst werden.
    /*** Laut Christian kann SHOPDOMAIN alles sein, funktioniert trotzdem ~magic~ ***/
    directIntegration.serviceUrl            = '//service.findologic.com/ps/SHOPDOMAIN/index.php?outputAdapter=HTML_2.0&';

    /*** Hier müssen folgende Selektoren angepasst werden:
    /*** LOAD-MORE-RESULTS: Die Klasse oder ID des Buttons.
    /*** ITEM-CONTAINER: Das (möglichst unterste) Element vor dem Product Listing/Grid.***/
    directIntegration.loadButtonSelector    = '.LOAD-MORE-RESULTS';
    directIntegration.itemContainer         = '.ITEM-CONTAINER';
}

initValues();

/***
 * 
 * Ab hier muss dank initValues(); nichts mehr angepasst werden.
 *
 ***/

function loadAdditionalItems() {
    var query       = jQuery.extend({}, directIntegration.queryString);
    query['count']  = directIntegration.wantedItems;
    queryString     = jQuery.param(query);
    var requestUrl  = serviceUrl + queryString;
    jQuery.ajax({
        url: requestUrl,
        success: function (html) {
            var parsedHtml = jQuery('<div>').html(html);
            var prevScroll = $(window).scrollTop();
            jQuery(directIntegration.itemContainer) = parsedHtml.find(directIntegration.itemContainer);
            $(window).scrollTop(prevScroll);
        }
    });
}

jQuery(directIntegration.loadButtonSelector).click(function(){
    directIntegration.wantedItemAmount += directIntegration.loadItemStepSize;
  	loadAdditionalItems();
});
</code>

===== Standard Fix für den weitere Filter Link =====

Da "weitere Filter" von Haus aus nicht funktioniert, hab ich hier einen kleinen Codeschnipsel, der in 99% der Fälle funktionieren sollte.
Gehört ins Search Success Callback.

<code javascript>
jQuery("#flExpandMoreFilters").addClass("flFilter");

jQuery('#flExpandMoreFilters').click(function(event) {
  	event.preventDefault();
  	if (jQuery('#flMoreFilters').css('display') == 'none') {
    	jQuery('#flMoreFilters').show();
    } else {
    	jQuery('#flMoreFilters').hide();
    }
});
</code>

===== Timeout des Fallbacks verändern =====

Im Pre Search Callback kann der Fallback Timeout verändert werden (Bsp: 4s)
<code javascript>
directIntegration.OPERATION_TIMEOUT_MS=4000;
</code>

===== Shopeigene Suche nutzt ebenfalls wie die DI ein AJAX-Request mit # in URL =====

Um unsere Suche zu integrieren und die Shopstandardsuche als Fallback zu erhalten folgende Lösung:

**Init Callback:**

<code javascript>
jQuery('#search_input').attr('type','text');

/*
The original search form has an Ajax search attached (see http://stage.delikateska.ru/src/js/search.js) that interferes with our search, so clone it (by default jQuery does not clone event handlers), hide it and insert our cloned form.
*/

var searchSection = jQuery("section.search");
var originalSearch = searchSection.find("form");
var clonedSearch = originalSearch.clone();

/*
Add some classes so the original form can be submitted in the error callback
*/
originalSearch.addClass("fl-original-search");
clonedSearch.addClass("fl-cloned-search");

originalSearch.hide();
searchSection.append(clonedSearch);
</code>

**Error Callback:**

<code javascript>
/*
Hide our cloned search form (see the init callback for details), then show and submit the original form
*/
jQuery(".fl-cloned-search").hide();

/*
Use the shop's jQuery / $ as the event handler exists only with the shop's jQuery, not ours
*/
window.$(".fl-original-search").show().submit();
</code>

===== Submit-Event vom Suchfeld entfernen =====

<code javascript>
window.$("#search_mini_form").off("submit");
</code>

===== Ein bestehendes Menü nach den Filtern einfügen =====

<code javascript>
// menü abspeichern [WICHTIG: detach() nicht html()]
var menu = jQuery(".col-left").detach();
jQuery(".main").empty().html(response);
jQuery(".fl-nav-bar").append(menu);
</code>

===== Inhalte nur zeigen, wenn Benutzer eingeloggt ist =====

<code javascript>
if (utils.getUsergrouphash() == '') {
  jQuery('.logged_in').remove();  
}
</code>

===== Unterschiedliche Suchfelder für Mobile und Desktop =====

Dies bringt leider bei uns noch einen Fehler, daher müssen wir dies im Pre Search Callback wie folgt lösen (beispielhaft):

<code javascript>
/* There are multiple search fields, one for desktop and one for mobile. Get the value from the one that's currently visible. */
var query = jQuery("input[type=text][name='Params[SearchParam]']:visible").val();

var queryParams = utils.parseQueryString(queryString);
queryParams.query = query;
var newQueryString = jQuery.param(queryParams);
return newQueryString;
</code>

Zusätzlich kann es nötig sein das zweite (unsichtbare) Suchfeld am submitten zu hindern. Dazu im INIT Callback:

<code javascript>
/* Detach not visible search form */
jQuery("input[type=text][name='searchparam']:not(:visible)").detach();
</code>

===== Direkt auf die Landingpage weiterleiten =====

In den ''Search-Success Callback''

<code javascript>
var landingPage = response.find(".fllandingPage");
if (landingPage.length > 0) {
  window.location = landingPage.find("a").attr("href");
  return;
}
</code>


===== Turn regular text filters into dropdown filters =====

So that dropdown + multiselect works.

Only ''threshold'' filter values shown, the rest will be hidden behind an ''show more'' link.

Add to ''Search-Success Callback'':

<code javascript>
/* Helper for turning select filters into expandable lists. */
function makeExpandableList(filterSelector, threshold) {
    
    var filter = jQuery(filterSelector);
    
    /* If the filter does not exist, cop out */
    if (filter.length < 1) {
        return;
    }
    
    /* Build the required HTML structure for the new filter value lists */
    var regularFilters = jQuery('<ul>', {
        'class': 'fl-filter'
    });
    var extraFilters = jQuery('<ul>', {
        'class': 'fl-filter fl-filter-extra'
    });
    
    /* Adapt selectors so this is treated as a select filter now. */
    filter.removeClass('fl-filter-type-label');
    filter.addClass('fl-filter-type-select');
    filter.addClass('fl-select-filter');    

    /* In order for the DI click handler for the expander to work, the filter values need to be wrapped in an extra div.fl-select-filter */
    var flSelectFilterWrapper = jQuery('<div>', {
        'class': 'fl-select-filter'
    });
    filter.append(flSelectFilterWrapper);

    /* 
     * Get the filter values while removing them from the DOM
     * Be sure to use detach() and not remove(), so the click handlers on the filter values don't get lost
     */
    var filterValuesList = filter.find('ul').detach();
    
    /* Set the threshold so that all selected filter values are shown */
    threshold = Math.max(threshold, filterValuesList.find('li.fl-multiselect-checked').length);
    
    /* Move selected filters to the top of the list */
    filterValuesList.find('li.fl-multiselect-checked').detach().prependTo(filterValuesList);
    
    /* Build a list of displayed and hidden filter values, depending on the threshold */
    filterValuesList.find('li').slice(0, threshold).appendTo(regularFilters);
    /* filterValuesList will now only contain the remaining elements, so add them all to the extraFilters */
    filterValuesList.find('li').appendTo(extraFilters);
    
    /* Append the new filter values lists */
    flSelectFilterWrapper.append(regularFilters);
    flSelectFilterWrapper.append(extraFilters);

    /* Build the expander = More+ / Less- link */
    var expander = jQuery('<span>', {
        'class': 'fl-expand-select-values'
    }).html('' + 
            '<a href="#">' +
                '<span class="fl-expand-text">Mehr</span>' +
                '<span class="fl-collapse-text">Weniger</span>' +
                '<span class="fl-expand-icon"></span>' +
            '</a>');
    /* Only show the more filter button if there are extra filters available. */
    if (extraFilters.find('li').length > 0) {
        expander.insertAfter(extraFilters);
    }
}

/* Call with the selector of the filter box, like this: */
makeExpandableList('.fl-filter-name-Verwendung', 6);
makeExpandableList('.fl-filter-name-vendor', 6);
</code>

===== (html3) Multicolor filter tile image =====

In ''Custom Style'' (replace [name of the color] with the appropriate value from the tile's selector):

<code css>
.fl-color-[name of the color] .fl-color-picker-tile {
    background: url('https://cdn.findologic.com/autocomplete/img/patterns/multicolor.svg');
    background-size: cover;
    background-position-x: 30%; /* Remove this line and the one below to show the black boundaries of the spectrum. */
    background-size: 120%;
    transform: rotate(-90deg); /* Remove this line to show the gradient horizontally instead of vertically. */
}
</code>

===== (html3-Template) Mobile Fix, using "px" instead of "rem"  =====

Set "max-width: 1024px" depending on the shops mobile-breakpoint

<code css>
@media screen and (max-width: 1024px) {
    .fl-outer-container {
        .accordion-navigation {
            a.fl-filter-name, .content {
                font-size: 14px !important;
            }
        }
        .button, .label, .accordion-navigation>a.fl-filter-name {
            padding: 10px !important;
        }  
        .fl-range-slider {
            .prefix, .postfix {
                min-height: 0 !important;
                padding-top: 0 !important;
            }
            .ui-slider-handle.ui-state-default {
                height: 20px !important;
                width: 20px !important;
            }
        }
        .findologic-slider {
            height: 10px !important;
            &.row {
                padding-top: 0;
            }
            .fl-range-slider-filter-button {
            width: 100%
            }
        }
        .fl-color-picker-tile-wrapper {
            width: 35px !important;
            height: 35px !important;
            .fl-color-picker-unknown-color {
                border: none;
            }
        }
        .fl-color-picker>li {
            width: 40px !important;
            &:nth-of-type(8n+1) {
                clear: none;
            }
        }
        select {
            font-size: 12px !important;
        } 
    }
}

@media screen and (max-width: 500px) {
    .fl-outer-container {
        .fl-filter-container .fl-filter-box-wrapper {
            width: 100%;
        }
    }
}
</code>

===== (html3) Color filter tile patterns/images =====

In ''Search Success Callback'' (replace [name of the color] with the appropriate value from the tile's selector, and [pattern] with the name of the pattern (i.e. 'polkadots')):

<code javascript>
function setColorPattern(colorName, pattern) {
    flRequire(['utils/svg-injector'], function (SVGInjector) {
        var selector = '.fl-color-picker-tile[title="' + colorName + '"]';
        var patternUrl = 'https://cdn.findologic.com/autocomplete/img/patterns/' + pattern + '.svg';
        var container = jQuery(selector);
        container.append(jQuery('<img>', {
            'data-src': patternUrl
        }));
        SVGInjector(container.find('img'), undefined, function () {
            var svg = container.find('svg');
            svg[0].setAttribute('viewBox', '0 0 600 600');
            svg[0].setAttribute('preserveAspectRatio', 'MaxYmax');
            svg.css('width', '100%');
            svg.css('height', '100%');
        });
    });
}

/* Use like this: setColorPattern('[name of the color]', '[pattern]'); */
setColorPattern('checkered', 'chessboard');
setColorPattern('dotted', 'polkadots');
setColorPattern('stripes', 'striped');
</code>

The available patterns are:
  * [[https://cdn.findologic.com/autocomplete/img/patterns/chessboard.svg|chessboard]]
  * [[https://cdn.findologic.com/autocomplete/img/patterns/polkadots.svg|polkadots]]
  * [[https://cdn.findologic.com/autocomplete/img/patterns/striped.svg|striped]]

Patterns can be styled using the ''fill'' CSS properties (with ''!important'') on the selectors provided for the individual patterns:
  * chessboard: ''.rect-color-1'', ''.rect-color-2''
  * polkadots: ''.dots *'', ''.background''
  * striped: ''.stripes *'', ''.background''

Styling example:

<code css>
    .fl-color-picker-tile[title="Blau"] {
        .rect-color-1 {
            fill: $findorange !important;
        }
        .rect-color-2 {
            fill: black !important;
        }
    }
    .fl-color-picker-tile[title="Dark Blue"] {
        .dots * {
            fill: red !important;
        }
        .background {
            fill: black !important;
        }
    }
    .fl-color-picker-tile[title="Clover"] {
        .stripes * {
            fill: blue !important;
        }
        .background {
            fill: cyan !important;
        }
    }
</code>

{{:fl:internal:support:directintegration:2015-08-24-113705_235x86_scrot.png|}}

Please collect future requests for shapes/patterns so they can be implemented properly at once in the future. If this code2copy proves to be popular, it will be available by default in the callbacks of the future.

===== Link to product URL's in Oxid =====

Oxid adds parameters to every page which will be passed through our frontends and cause the malfunction of external Links in the Template. e.g. product URL's.

To strip Oxid's parameters, use the following code inside the {foreach result} loop in smarty Template.
Use {$STRIPPED_URL} instead of {$ITEM.URL} for correct URL's

<code>
            {* $ITEM.URL is suffixed with the query parameters, eg. ?cl=search&searchparam=mural; remove these, otherwise Oxid will do a search when clicking on that link *}
            {assign var=STRIPPED_URL value=$ITEM.URL|regex_replace:"/\?.*$/":""}
</code>

===== Fix display errors on mobile (wrong font sizes, padding, margins) =====

Set the ''$mobile-font-size'':

<code css>
.fl-outer-container {
  
  @import 'findologic3_settings.scss';
  
  $mobile-font-size: 1rem;
  
  @import 'foundation.scss';
  @import 'findologic3.scss';
    
  // Custom styles go here.
  ...
} 
</code>

===== Display from - to for the chosen price filter =====

Use this in the ''CHOSEN_FILTER_TEMPLATE'' capture:

<code>
{if $FILTER_KEY == 'price'}
  {$FILTER_NAME_HUMANIZED}:
  {assign var=PRICES value=' - '|explode:$FILTER_VALUE.display}
  {$PREFIX_CURRENCY}
  {$PRICES[0]|number_format:2:$DECIMAL_SEPARATOR:$THOUSANDS_SEPARATOR}
  {$POSTFIX_CURRENCY} -
  {$PREFIX_CURRENCY}
  {$PRICES[1]|number_format:2:$DECIMAL_SEPARATOR:$THOUSANDS_SEPARATOR}
  {$POSTFIX_CURRENCY}
{else}
...
</code>

===== Output the result item title without highlighting =====

Make sure that ''withHighlight;true'' is turned on, otherwise ''$ITEM.TITLE'' will be empty. Then in the template use

<code>
{foreach from=$RESULT key=I item=ITEM name=RESULTS}
    {assign var=STRIPPED_TITLE value=$ITEM.TITLE|strip_tags}
    {$STRIPPED_TITLE}
    ....
{/foreach}
</code>


===== Display Price-Input fields in full width on Desktop-Grid =====

This results in the same input-fields as in medium-grid

<code javascript>
// Get the form and remove the large-classes
var newPriceForm = jQuery(response).find('.findologic-slider-form-price');
jQuery(newPriceForm).find('.fl-range-slider-unit').removeClass('large-2');
jQuery(newPriceForm).find('.flSelectedMin, .flSelectedMax').removeClass('large-3');
// Replace the adapted price-form with the original form
jQuery(response).find('.findologic-slider-form-price').replaceWith(newPriceForm);
</code>

===== Remove ALL Filters in Template =====

To remove ALL filters in the template is not enough to delete the {generated_filters}-line, so you must also remove the filterbox-div (otherwise the filter button is shown in the mobile view)


===== Adapt default-css-breakpoints  =====

In Custom-styles where beneath the comment "SCSS variable overrides go here."

<code css>
$small-breakpoint: 768px;
$medium-breakpoint: 1023px;
$large-breakpoint: 1440px;
$xlarge-breakpoint: 1920px;
</code>

Media-query ranges are set according to the breakpoints, but there are also variables to set it: 

<code css>
$small-range:   (0px, 768px);
$medium-range:  (769px, 1023px);
$large-range:   (1024px, 1440px);
$xlarge-range:  (1441px, 1920px);
</code>


===== How to replace the search field in order to get rid of all events on it =====

This is necessary if shop-provided events on the search field/-form break Direct Integration, and it is not possible to remove this events in any way (such as Vanilla JS events, unknown libraries, and out-of-scope event handlers).

The basic idea: Clone the search form **without** events, insert the clone, and remember the original form (which still has events) so it can be submitted in case of fallback.

Init callback:

<code javascript>
/* Remove current scripts from input by cloning. */
window.flOriginalSearchForm = jQuery('#search');
var searchFormCopy = jQuery('#search').clone();
searchFormCopy.insertAfter(window.flOriginalSearchForm);
window.flOriginalSearchForm.detach();
</code>

Pre-search callback:

<code javascript>
var query = utils.parseQueryString(queryString);
/* The seach field element has the name "q", so we need to rewrite that to query. If it is undefined, though, this indicates that the search was triggered via hashchange. In that case, q has already been rewritten to query in the hash, so we don't need to do any more rewriting. */
if (typeof(query.q) !== 'undefined') {
    query.query = query.q;
    delete query.q;
}
var newQueryString = jQuery.param(query);
return newQueryString;
</code>

Error callback:

<code javascript>
/* In case of error, submit the original search form, which was replaced earlier in the init callback by a clone. */
window.flOriginalSearchForm.submit();
</code>


===== Disable scroll-to-top animation for everything except pagination  =====

Pre-* callbacks:

<code javascript>
/* Prevent scrolling because it's disruptive when using filters. */
if (typeof(directIntegration.reallyScrollToTop) === 'undefined') {
    directIntegration.reallyScrollToTop = directIntegration.scrollToTop;
	directIntegration.scrollToTop = function () {};
}
</code>

*-Success callbacks:

<code javascript>
/* Pagination should still scroll to top, unlike filters. */
response.find('.fl-pagination-container a').click(function () {
    directIntegration.reallyScrollToTop();
});
</code>

===== Deactivate autocorrect function for mobile smartphones  =====

Init Callback:

<code javascript>
jQuery(searchField).attr('autocorrect', 'off');
jQuery(searchField).attr('autocapitalize', 'off');
jQuery(searchField).attr('spellcheck', 'false');
</code>

===== Make Google Website Search in google.de/com/etc. compatible with FINDOLOGIC  =====

Example for SHOPWARE! Other shop systems need an light modified code!

<code javascript>
<script type="application/ld+json">
{
   "@context": "http://schema.org",
   "@type": "WebSite",
   "url": "https://www.###DOMAIN###.de/",
   "potentialAction": {
     "@type": "SearchAction",
     "target": "http://www.sandtler24.de/###DOMAIN###/search?sSearch={search_term_string}",
     "query-input": "required name=search_term_string"
   }
}
</script>
</code>



===== Mobile - iPhone with iOS9 is jumping/scrolling after typing in the searchfield  =====


**Reason:** Some elements are too wide, and exceeds the border of the phone. Then the phone tries to display the whole content, which means it zooms out. Afterwards the phone zooms in again and view is at the different point of the site. It seems as the phone have scrolled the site.

**Solution:** Find the element which is too wide and fix the width with CSS. Hint: It could be the mobile Smart-Suggest, if a custom width is set in the Direct-Integration Custom-Styles.

If this isn't the problem, there is one more option to get rid of this behaviour as described here:
[[http://kihlstrom.com/2015/shrink-to-fit-no-fixes-zoom-problem-in-ios-9/|Shrink-to-fit-iOS9]]

Normally every responsive site has an <meta> tag with the name "viewport" in the <head> of the site. Ask the customer to simply add shrink-to-fit=no to his <meta> tag.

Example <meta>-tag:
<code html>
<meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
</code>

If the customer is not able to make this change, it would be also possible to add shrink-to-fit=no via Javascript in the init-Callback of Direct-Integration.
Attention: This is not the best solution, it's always better to let the customer add it to the sites template.

<code javascript>
if(jQuery('meta[name=viewport]').length) {
    var metaTag = jQuery('meta[name=viewport]');
    var viewportContent = jQuery(metaTag).attr('content');
    
    // If shrink-to-fit is not set, add it.
    if(viewportContent.toLowerCase().indexOf('shrink-to-fit') == -1) {
        newViewportContent = viewportContent + ', shrink-to-fit=no';
        jQuery(metaTag).attr('content', newViewportContent);
    }
} else {
    // If no viewport meta-tag exists, create one and set some attributes for mobile
    jQuery('<meta/>', {
        name: 'viewport',
	content: 'width=device-width, initial-scale=1.0, shrink-to-fit=no'
    }).appendTo('head');
}
</code>



===== Shopware 5 - Click in Smart Suggest =====

Shopware 5 has per default an event-listener on the body-tag, where the searchfield gets hidden when clicking outside of the input field.

An quick solution is to remove the event-listener below a certain width. For the shopware default theme 480 seems to be the right width. Adapt this value if necessary.

The code has to be executed after the user clicks the button to show the searchfield.

<code javascript>
$('.navigation--entry.entry--search .entry--link').click(function() {
	if ($(window).width() < 480) {
	    $('body').unbind('click');
	    $('body').unbind('touchstart');
	    $('body').unbind('touchend');
	}
});
</code>

===== Insert Guided Shopping anywhere on the page =====

Add this to the ''Init Callback''

<code javascript>
/* Build an element with the snippet from the customer-login Guided Shopping configuration */
var guidedShoppingLink = jQuery('<a class="fl-wizard" href="#TV-Guide">TV-Guide</a>');

/* Use the icons available in every DI shop, see https://fortawesome.github.io/Font-Awesome/icons/ for the list */
var guidedShoppingIcon = jQuery('<span class="icon-television"></span>');
/* ... or use an Iconfinder icon, that you uploaded to the store */
var guidedShoppingIcon = jQuery('<img src="//shop.com/icons/television.png">');

/* Optionally add an icon before the link text */
guidedShoppingLink.prepend(guidedShoppingIcon);
/* ... alternatively add the icon after the link text */
guidedShoppingLink.append(guidedShoppingIcon);
/* ... or just replace the complete text with an icon */
guidedShoppingLink.html(guidedShoppingIcon);

/* Now insert the Guided Shopping link somewhere on the page, in this case right after the #box_languages element, on the same level */
guidedShoppingLink.insertAfter('#box_languages');
/* ... or before */
guidedShoppingLink.insertBefore('#box_languages');
/* See jQuery's DOM Insertion methods for more ways to insert the Guided Shopping */

/* And finally make sure that clicking the Guided Shopping link only opens the Guided Shopping */
jQuery('.fl-wizard').on('click', function(e) {
    e.preventDefault();
});
</code>

===== Insert Guided Shopping in the search / navigation template ======

  - Take the Guided Shopping integration snippet from the customer-login, it will look something like this: <code html>
<a class="fl-wizard" href="#TV-Guide">TV-Guide</a>
</code>
  - Add an icon, for example: <code html>
<a class="fl-wizard" href="#TV-Guide"><span class="icon-television"></span>TV-Guide</a>
</code>
    * or use a custom image: <code html>
<a class="fl-wizard" href="#TV-Guide"><img src="//shop.com/icons/television.png">TV-Guide</a>
</code>

===== Deactivate / activate FINDOLOGIC DI temporarily in the web browser  ======

Deactivate FINDOLOGIC DI temporarily in the web browser (browser console):

<code>
localStorage.setItem('findologic-fallback-start', new Date(Date.now())); location.reload();
</code>

Activate FINDOLOGIC DI temporarily in the web browser (browser console)

<code>
localStorage.removeItem('findologic-fallback-start'); location.reload();
</code>

===== HowTo use Google Tag Manager GTM with FINDOLOGIC Direct Integration ======

1. Pushen der Daten in den Datalayer (muss im pre-search callback platziert werden. Idealerweise in einem try-catch block)

<code>
dataLayer.push({'fsearch': query.query});
</code>

Mit dieser Funktion wird die Suchanfrage nach einem Klick in den Datalayer gepusht und kann ausgelesen werden.


2. Konfiguration des Google Tag manager:

2.1 Einrichtung der Variablen:

Auslesen des Suchbegriffs auf dem DataLayer:

{{:fl:integrators:directintegration:image002.jpg|}}

Umschreiben der URL:

{{:fl:integrators:directintegration:image005.jpg|}}

Dieser Schritt ist offenbar notwendig, da GA den Suchbegriff nicht DIREKT aus dem Datalayer ziehen kann sondern nur indirekt über die URL.

Mit dieser Funktion übergebe ich daher eine modifizierte URL an GA

2.2. Einrichten des Triggers:

{{:fl:integrators:directintegration:image008.jpg|}}

2.3. Einrichten des Tags:

{{:fl:integrators:directintegration:image011.jpg|}}

Wichtig ist, dass dieser Tag erst ausgelöst wird, wenn auf das Suchfeld geklickt wird.

Beim initialen Pageload ist der Suchbegriff ja noch nicht vorhanden. Diese wird erst nach dem Klick auf der Suchfeld von findologic nachgeladen.

===== XTCsid aus Pfad für Navigation entfernen ======

In eingigen Fällen hängt xt:c eine session ID in den Pfad mit an. Daher kann der Navigation Success Callback nicht greifen.
Um dies zu fixen, in den Pre-Navigation Callback einfügen:

Achtung: 

<code>
var query = utils.parseQueryString(queryString);
 if ("attrib" in query && "cat_url" in query.attrib){   
    var new_cat_url = query.attrib.cat_url[0].replace(/\/XTCsid\/[a-z0-9]{32}/g, '');
    query.attrib.cat_url[0]=new_cat_url;
}
var newQueryString = jQuery.param(query);
return newQueryString;
</code>

===== Limit text width to a single line with ellipsis ======

<note warning>Smarty 2's ''truncate'' modifier is **considered harmful and should not be used** due to problems with multi-byte characters. The solution below offers a SCSS solution to the challenge of cutting off long strings.</note>

Apply the following SCSS class to the affected elements. You may need to adapt the ''max-width'' property for your use case.

<code>
// Ellipsizes long strings. Use this instead of Smarty 2's truncate modifier.
.fl-ellipsize {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    // max-width has no visible effect, but it must be set for the ellipsis
    // to trigger at the end of the column's width.
    max-width: 1rem;
}
</code>